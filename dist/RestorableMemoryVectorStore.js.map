{"version":3,"file":"RestorableMemoryVectorStore.js","sources":["../src/RestorableMemoryVectorStore.ts"],"sourcesContent":["/*******************************************************************************\n*                                                                              *\n*                         RestorableMemoryVectorStore                          *\n*                                                                              *\n*******************************************************************************/\n\n  export type Serialized = {               // dictated by VectorStore.Serialized\n    lc:number,\n    type:'constructor',\n    id:string[],\n    kwargs:Record<string,any>,\n  }                  // I hate this format, but I also want to remain compatible\n\n/**** import required components from langchain ****/\n\n  import { MemoryVectorStore }   from 'langchain/vectorstores/memory'\n  import { Embeddings }          from '@langchain/core/embeddings'\n  import { Document }            from 'langchain/document'\n\n/**** RestorableMemoryVectorStore ****/\n\nexport class RestorableMemoryVectorStore extends MemoryVectorStore {\n  static async fromJSON (\n    JSONString:string, Embedder:Embeddings\n  ):Promise<RestorableMemoryVectorStore> {\n    const JSONObject = JSON.parse(JSONString)\n    \n    if (\n      (JSONObject.lc == null) || (JSONObject.type !== 'constructor') || \n      ! Array.isArray(JSONObject.id)\n    ) {\n      throw new Error('invalid serialization format')\n    }\n    \n    const Store = new RestorableMemoryVectorStore(Embedder)\n      if (JSONObject.kwargs?.docs == null) {\n        throw new Error('no documents in serialization')\n      } else {\n        const Documents:Document[] = []\n        const Vectors:number[][]   = []\n        \n        for (const DocData of JSONObject.kwargs.docs) {\n          if (DocData.pageContent && DocData.vector) {\n            Documents.push(new Document({\n              pageContent:DocData.pageContent,\n              metadata:   DocData.metadata || {}\n            }))\n            Vectors.push(DocData.vector)\n          }\n        }\n        \n        Store.addVectors(Vectors, Documents)\n      }\n    return Store\n  }\n}"],"names":["RestorableMemoryVectorStore","MemoryVectorStore","JSONString","Embedder","JSONObject","Store","Documents","Vectors","DocData","Document"],"mappings":";;AAqBO,MAAMA,UAAoCC,EAAkB;AAAA,EACjE,aAAa,SACXC,GAAmBC,GACkB;AAC/B,UAAAC,IAAa,KAAK,MAAMF,CAAU;AAGrC,QAAAE,EAAW,MAAM,QAAUA,EAAW,SAAS,iBAChD,CAAE,MAAM,QAAQA,EAAW,EAAE;AAEvB,YAAA,IAAI,MAAM,8BAA8B;AAG1C,UAAAC,IAAQ,IAAIL,EAA4BG,CAAQ;AAChD,QAAAC,EAAW,QAAQ,QAAQ;AACvB,YAAA,IAAI,MAAM,+BAA+B;AAC1C;AACL,YAAME,IAAuB,CAAC,GACxBC,IAAuB,CAAC;AAEnB,iBAAAC,KAAWJ,EAAW,OAAO;AAClC,QAAAI,EAAQ,eAAeA,EAAQ,WACvBF,EAAA,KAAK,IAAIG,EAAS;AAAA,UAC1B,aAAYD,EAAQ;AAAA,UACpB,UAAYA,EAAQ,YAAY,CAAA;AAAA,QAAC,CAClC,CAAC,GACMD,EAAA,KAAKC,EAAQ,MAAM;AAIzB,MAAAH,EAAA,WAAWE,GAASD,CAAS;AAAA,IAAA;AAEhC,WAAAD;AAAA,EAAA;AAEX;"}